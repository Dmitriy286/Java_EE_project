package com.example.java_ee_project;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import entity.Human;

import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class JDBCexample {
    private static final String url = "jdbc:postgresql://localhost:5432/postgres";
    private static final String user = "postgres";
    private static final String password = "admin";

    //создаем простое подключение:
    public Connection getNewConnection() throws SQLException {

        //todo Подключаем драйвер. Зачем??? Работает все и без этого - в принципе создается сам.
        try {
            Class.forName("org.postgresql.Driver");
            System.out.println("---!!!Здесь загружается драйвер!!!---");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }

        return DriverManager.getConnection(url, user, password);
    }

    //создаем пул подключений, необходимо добавить дополнительную зависимость, например HikariCP
    public DataSource getDataSource() {
        HikariConfig config = new HikariConfig();
        config.setUsername(user);
        config.setPassword(password);
        config.setJdbcUrl(url);
        DataSource ds = new HikariDataSource(config);
        return ds;
    }

    public int executeUpdate(String query) throws SQLException {
        Connection connection = getNewConnection();
        //статический стейтмент
        // Для Insert, Update, Delete
        Statement statement = connection.createStatement();

        int result = statement.executeUpdate(query);
        System.out.println("Проверяю, что возвращает executeUpdate");
        System.out.println(result);
        connection.close();
        return result;
    }

    public void createTestTable(String schemaName, String tableName) throws SQLException {
        //todo переделать на try catch, чтобы соединение закрывалось независимо от ошибок

        Connection connection = getNewConnection();
        Statement statement = connection.createStatement();

        String testTableQuery = "CREATE TABLE " + schemaName + "." + tableName +
                " (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name TEXT);";

        boolean res = statement.execute(testTableQuery);

        connection.close();

        System.out.println("Проверка создания таблицы:");
        System.out.println(res);
    }

    public void insertRow(String testInsertQuery) throws SQLException {
        executeUpdate(testInsertQuery);
    }

    public void insertFewRows(String schemaName, String tableName){
        Connection connection = null;
        Statement statement = null;
        try {
            connection = getNewConnection();
            //отключаем автокоммит. Теперь коммит необходимо выполнять явно.
            connection.setAutoCommit(false);
            statement = connection.createStatement();

            //добавим немного динамики в запросы
            String query_1 = "INSERT INTO " + schemaName + "." + tableName + " (name, money)" + " VALUES ('one', 500)";
            String query_2 = "INSERT INTO " + schemaName + "." + tableName + " (name, money)" + " VALUES ('two', 300)";
            String query_3 = "INSERT INTO " + schemaName + "." + tableName + " (name, money)" + " VALUES ('three', 400)";

//            addBatch(): Adds the given SQL command to the current list of commands
//             for this Statement object.
//             The commands in this list can be executed as a batch
//             by calling the method executeBatch.
            statement.addBatch(query_1);
            statement.addBatch(query_2);
            statement.addBatch(query_3);

            System.out.println("Здесь должен быть выведен массив обработанных строк через метод addBatch");
            System.out.println(statement.executeBatch());
            connection.commit();

            System.out.println("Проверка, закрыто ли соединение и стейтмент:");
            System.out.println(connection.isClosed());
            System.out.println(statement.isClosed());

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        finally {
            try {
                System.out.println("Connection: " + connection.isClosed() + "\n" +
                        "Statement: " + statement.isClosed());
                connection.close();
                System.out.println("Connection: " + connection.isClosed() + "\n" +
                        "Statement: " + statement.isClosed());
                statement.close();
                System.out.println("Connection: " + connection.isClosed() + "\n" +
                        "Statement: " + statement.isClosed());
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }
    }

    public void dropRow(String tableName, int id) throws SQLException {
        String testDeleteQuery =
                "DELETE FROM " + tableName + " WHERE id = " + id + ";";
        executeUpdate(testDeleteQuery);
    }

    //Обратить внимание на необходимость закрытия соединения и result set!!!
    public ResultSet findByName(String schemaName, String tableName, String name) throws SQLException {
        String query = "SELECT * FROM " + schemaName + "." + tableName + " WHERE name = ?;";
        Connection connection = getNewConnection();
        //нестатический стейтмент
        PreparedStatement statement = connection.prepareStatement(query);

        statement.setString(1, name);

        System.out.println("Вызов метода findByName, проверка исполнения стейтмента:");
        System.out.println(statement.execute());

        ResultSet resultSet = statement.getResultSet();
        System.out.println("Проверка, закрыто ли соединение:");
        System.out.println(connection.isClosed());

        connection.close();
        System.out.println("Проверка, закрыто ли соединение после метода close():");
        System.out.println(connection.isClosed());

        return resultSet;

    }

    public void transaction() throws SQLException {
        Connection connection = getNewConnection();
        connection.setAutoCommit(false);
        String query = "INSERT INTO test VALUES (10, 'test_ten', 'message_ten');";
        connection.createStatement().executeUpdate(query);
        connection.commit();
        Statement statement = connection.createStatement();
        statement.execute("SELECT * FROM test");
        ResultSet resultSet = statement.getResultSet();
        int count = 0;
        while (resultSet.next()) {
            System.out.println(resultSet.getString("name"));
            count++;
        }
        System.out.println(count);
    }

    public List<Human> getAllHumans() {
        //todo зачем вначале приравнивать к null? - потому что из блока try она не будет видна
        Connection connection = null;
        Statement statement = null;
        List<Human> humans = new ArrayList<>();
        try {
            connection = getNewConnection();
            statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery("SELECT * FROM new_schema.human");
            while (resultSet.next()) {
                int id = resultSet.getInt(1);
                String name = resultSet.getString("name");
                int money = resultSet.getInt("money");
                Human human = new Human(id, name, money);
                humans.add(human);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                connection.close();
                statement.close();
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }
        return humans;
    }

    public void insertNewHuman(String name) {
        Connection connection = null;
        PreparedStatement statement = null;
        String query = "INSERT INTO new_schema.human (name, money) VALUES (?, ?)";
        try {
            connection = getNewConnection();
            statement = connection.prepareStatement(query);
            statement.setString(1, name);
            statement.setInt(2, 100);

            statement.execute();
            System.out.println("Добавляется новая строка");

        }

        catch (SQLException e) {
            throw new RuntimeException(e);
        }

        finally {
            try {
                connection.close();
                statement.close();
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }
    }

}
